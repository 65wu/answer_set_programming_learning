# 主要思想

## 封闭世界假设(Closed world assumption)

在了解封闭世界假设之前，先了解一下它的对立面，即开放世界假设。 事实上，我们现实生活中的推理都为开发世界假设。

在推理时，知识往往是不完全的，会遇到不确定的情况，开放世界假设在这个情况时会给出`unknown`的解答； 而封闭世界假设则将一切不明白，不确定的事物都强行判定为`failure`。 比如：

`事实: 李明会游泳`

`问题: 李明会开车吗?`

```
开放世界假设: 不确定，因为李明既可以会游泳也可以会开车，或者只会游泳不会开车
封闭世界假设: 李明不会开车
```

封闭世界假设的思想来源于数据库，再来看一个具体的例子，下面是一张简易的学生成绩表

| 姓名 | 科目  | 成绩 |
| -- | --- | -- |
| 张三 | c语言 | 85 |
| 李四 | c语言 | 79 |

如果我要查询李四的c语言这门课的成绩，数据库查询到该记录，正常返回成绩85分

但如果我想知道张三数据结构的成绩，数据库返回无结果，判定为`failure`。 这并不意味着张三没去参加这门考试，也不代表张三压根没选修这门课程，因为存在张三的成绩未录入到数据库的可能。

## 否定为失败(Negation as failure)

否定为失败是逻辑编程对封闭世界假设的进一步推广，它默认一切事物为假直到该事物被证明为真， 这同时也意味着当一个事物没被证明为真时，它的对立面是恒为真的。

## 非单调推理(Non-monotonic logic)

简单的来说，随着新知识加入知识库，推论的结果并不是单调递增的，这意味着原有的推论可能会被新知识推翻。

在这点上，和现实生活中的计划有些相像，比如：

* 打算星期天出门野炊，结果突然遇上雷暴雨，不得不放弃原有的计划呆在家里
* 打算立刻洗澡，结果遇上楼栋停水，只能推迟洗澡时间
* 打算赴约前往酒店，结果常走的道路施工，只好绕道

在asp中有一个`flying birds`的例子，如果只知道一个动物是鸟，而不知道其他条件，则默认这个动物能飞， 但后面得知这个动物是企鹅，则要撤回先前的结论，判定该动物不能飞。这里正是新加入了`这个动物是企鹅`的事实，从而推翻了之前`这个动物能飞`的结论
